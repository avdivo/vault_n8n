# VaultN8N

VaultN8N — это минималистичное серверное приложение для безопасного хранения, выдачи и удаления секретов (паролей, токенов и т.п.) через HTTP API. Оно разработано для интеграции с [n8n](https://n8n.io/) или для использования в качестве простого и легковесного хранилища секретов.

Проект создан с упором на простоту, предсказуемость, минимальные зависимости и небольшой размер Docker-образа.

## Оглавление

- [Установка и запуск](#установка-и-запуск)
  - [Быстрый старт для пользователей (рекомендуется)](#быстрый-старт-для-пользователей-рекомендуется)
  - [Запуск для разработки](#запуск-для-разработки)
- [Конфигурация](#конфигурация)
- [Использование API](#использование-api)
- [Интеграция с n8n](#интеграция-с-n8n)
- [Тестирование](#тестирование)
- [Публикация новой версии](#публикация-новой-версии)
- [Общие технические требования](#общие-технические-требования)
- [Советы по безопасности и эксплуатации](#советы-по-безопасности-и-эксплуатации)

---

## Установка и запуск

Существует два основных способа запуска приложения: быстрый старт для обычных пользователей и запуск для разработчиков.

### Быстрый старт для пользователей (рекомендуется)

Этот способ не требует клонирования репозитория и идеально подходит для быстрого развертывания. Все, что вам нужно — это установленный `Docker`, `docker-compose` и `curl`.

1.  **Выполните команду в терминале:**

    ```bash
    curl -sSL https://raw.githubusercontent.com/avdivo/vault_n8n/main/start.sh | bash
    ```

    > ✨ **Важно:** При первом запуске скрипт сгенерирует и выведет в консоль `AUTH_TOKEN` и `ENCRYPTION_KEY` в специальных рамках. **Обязательно скопируйте эти значения и сохраните их в надежном месте.** Эти данные также будут автоматически сохранены в файл `.env` в текущей директории для последующих запусков. Учтите, что без `ENCRYPTION_KEY` вы не сможете расшифровать ранее сохраненные секреты.

2.  **Что сделает этот скрипт?**
    *   **Создаст директорию `vault_n8n`** (если ее нет) для инкапсуляции файлов проекта.
    *   Скачает последнюю версию `docker-compose.yml` из репозитория **в директорию `vault_n8n`**.
    *   Проверит, существует ли **в родительской директории** файл `.env`. Если нет — создаст его.
    *   Проверит, заданы ли в `.env` ключи `AUTH_TOKEN` и `ENCRYPTION_KEY`. Если нет — сгенерирует их и добавит в файл.
    *   **Создаст пустой файл `vault_n8n/secrets.db`** (если его нет) для хранения секретов.
    *   Запустит последнюю версию приложения из [Docker Hub](https://hub.docker.com/r/avdivo/vault-n8n).

3.  **Готово!**
    Ваше приложение запущено. Необходимые для доступа `AUTH_TOKEN` и `ENCRYPTION_KEY` сохранены в файле `.env` в той же директории, откуда вы запускали скрипт. Сохранность этого файла обеспечивает сохранность ваших данных.

### Запуск для разработки

Этот способ предназначен для тех, кто хочет вносить изменения в код.

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/avdivo/vault_n8n.git
    cd vault_n8n
    ```

2.  **Запустите скрипт для разработки:**
    ```bash
    ./start-dev.sh
    ```
    > ✨ **Важно:** При первом запуске скрипт сгенерирует и выведет в консоль `AUTH_TOKEN` и `ENCRYPTION_KEY` в специальных рамках, если они отсутствуют в файле `.env`. **Обязательно скопируйте эти значения и сохраните их в надежном месте.** Учтите, что без `ENCRYPTION_KEY` вы не сможете расшифровать ранее сохраненные секреты.
    
    Этот скрипт автоматически подготовит `.env` файл (аналогично пользовательскому скрипту) и запустит `docker-compose`, но **соберет образ из локальных исходников**, что позволит вам сразу видеть ваши изменения.

3.  **Альтернативный ручной запуск (без Docker):**
    Если вы хотите запускать приложение напрямую для отладки:
    ```bash
    # Создайте и активируйте виртуальное окружение
    python -m venv venv
    source venv/bin/activate

    # Установите зависимости
    pip install -r requirements.txt

    # Убедитесь, что .env файл существует (можно запустить ./start-dev.sh один раз)

    # Запустите приложение
    uvicorn app.main:app --host 0.0.0.0 --port 8000
    ```
    После запуска приложение будет доступно по адресу `http://localhost:8200`.

## Конфигурация


Приложение конфигурируется через переменные окружения, которые автоматически создаются в файле `.env` при первом запуске с помощью скриптов.

-   **`AUTH_TOKEN`**: (Обязательно) Секретный токен для авторизации доступа к API.
-   **`ENCRYPTION_KEY`**: (Обязательно) 64-символьный hex-ключ для шифрования данных.
-   **`DATABASE_PATH`**: (Опционально) Путь к файлу базы данных SQLite. По умолчанию: `./secrets.db`.

## Использование API

Все эндпоинты имеют префикс `/api/v1` и требуют Bearer-авторизации.

> **Важно:** В примерах ниже используется переменная `$AUTH_TOKEN`. Перед выполнением команд вы должны заменить ее на ваш собственный `AUTH_TOKEN` из `.env` файла или определить ее в терминале:
> ```bash
> AUTH_TOKEN=$(grep AUTH_TOKEN .env | cut -d '=' -f2)
> ```

---

### Доступ к Swagger UI

Документация API доступна в интерактивном режиме (Swagger UI) по адресу: `http://localhost:8200/docs`. Здесь вы можете просмотреть все доступные эндпоинты, их параметры, модели данных и попробовать выполнить запросы.

---

### `POST /api/v1/secrets/single`

**Назначение:** Создание или обновление одного секрета. Если секрет с указанным ключом уже существует, его значение будет перезаписано.

**Входные данные (JSON Body):**
```json
{
  "key": "my_service_password",
  "value": "super_secret_password_123"
}
```

**Пример запроса:**
```bash
curl -X POST "http://localhost:8200/api/v1/secrets/single" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer $AUTH_TOKEN" \
     -d '{ "key": "my_service_password", "value": "super_secret_password_123" }'
```

**Пример успешного ответа (JSON):**
```json
[
  {
    "key": "my_service_password",
    "value": "super_secret_password_123"
  }
]
```

---

### `POST /api/v1/secrets/bulk`

**Назначение:** Массовое создание или обновление нескольких секретов.

**Входные данные (JSON Body):** Массив объектов, каждый из которых представляет секрет.
```json
[
  { "key": "api_key_prod", "value": "prod_api_token_xyz" },
  { "key": "db_user", "value": "admin_user" }
]
```

**Пример запроса:**
```bash
curl -X POST "http://localhost:8200/api/v1/secrets/bulk" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer $AUTH_TOKEN" \
     -d '[ { "key": "api_key_prod", "value": "prod_api_token_xyz" }, { "key": "db_user", "value": "admin_user" } ]'
```

**Пример успешного ответа (JSON):**
```json
[
  {
    "key": "api_key_prod",
    "value": "prod_api_token_xyz"
  },
  {
    "key": "db_user",
    "value": "admin_user"
  }
]
```

---

### `GET /api/v1/secrets`

**Назначение:** Получение одного или нескольких секретов по ключам.

**Входные данные (Query-параметр):**
- `keys`: Строка, содержащая один или несколько ключей, разделенных запятыми.
- **Фильтрация по маске:** Вы можете использовать символ `*` в качестве wildcard для поиска по шаблону.

**Примеры использования параметра `keys`:**
- `?keys=my_secret_key` — найти один конкретный ключ.
- `?keys=key1,key2,key3` — найти три конкретных ключа.
- `?keys=service_A_*` — найти все ключи, начинающиеся с `service_A_`.
- `?keys=key1,service_B_*` — найти ключ `key1` и все ключи, начинающиеся с `service_B_`.

**Пример запроса:**
```bash
curl -X GET "http://localhost:8200/api/v1/secrets?keys=my_service_password,api_key_*" \
     -H "Authorization: Bearer $AUTH_TOKEN"
```

**Пример успешного ответа (JSON):**
(Возвращаются только найденные секреты)
```json
[
  {
    "key": "my_service_password",
    "value": "super_secret_password_123"
  }
]
```

---

### `DELETE /api/v1/secrets`

**Назначение:** Удаление одного или нескольких секретов по ключам или маске.

**Входные данные (Query-параметр):**
- `keys`: Строка, содержащая один или несколько ключей/масок для удаления (правила те же, что и для `GET`).

**Пример запроса:**
```bash
curl -X DELETE "http://localhost:8200/api/v1/secrets?keys=db_user,api_key_prod" \
     -H "Authorization: Bearer $AUTH_TOKEN"
```

**Пример успешного ответа (JSON):**
(В ответе возвращаются удаленные секреты)
```json
[
  {
    "key": "db_user",
    "value": "admin_user"
  },
  {
    "key": "api_key_prod",
    "value": "prod_api_token_xyz"
  }
]
```

---

### Обработка ошибок

API использует стандартные HTTP-статус-коды для информирования об ошибках.

**`401 Unauthorized`**
- **Причина:** Неверный или отсутствующий `AUTH_TOKEN`.
- **Пример ответа:**
  ```json
  {
    "detail": "Неверный токен аутентификации"
  }
  ```

**`422 Unprocessable Entity`**
- **Причина:** Ошибка валидации входных данных. Например, отсутствует обязательное поле в теле запроса, неверный тип данных или невалидный JSON.
- **Пример ответа (неверное тело в `POST /secrets/single`):**
  ```json
  {
    "detail": [
      {
        "loc": [
          "body",
          "key"
        ],
        "msg": "field required",
        "type": "value_error.missing"
      }
    ]
  }
  ```

**`500 Internal Server Error`**
- **Причина:** Непредвиденная ошибка на стороне сервера (например, проблема с доступом к базе данных).
- **Пример ответа:**
  ```json
  {
    "detail": "Внутренняя ошибка сервера: <описание_ошибки>"
  }
  ```
> Примечание: в production-среде детальное описание ошибки может быть скрыто из соображений безопасности.

## Интеграция с n8n

Для взаимодействия с VaultN8N из n8n используется узел **HTTP Request**.

> **URL сервиса:** Если n8n и VaultN8N запущены в одной `docker-compose` сети, то для обращения к VaultN8N используйте имя сервиса как хост. Порт указывать не нужно, так как сервисы общаются по внутренним адресам. Корректный базовый URL будет `http://vault_n8n/api/v1`. В противном случае, используйте внешний IP-адрес или домен с портом (например, `http://ваш_домен:8200/api/v1`).

### Настройка авторизации

Авторизация настраивается один раз и используется для всех запросов.

1. В узле `HTTP Request` выберите:
   - **Authentication:** `Header Auth`
2. Нажмите `Create New Credential`.
3. В открывшемся окне:
   - **Name:** `Authorization`
   - **Value:** Вставьте `Bearer ваш_токен` (например, `Bearer my_secret_token_from_env_file`). **Важно:** Не забудьте написать слово `Bearer` и пробел перед самим токеном.

### Примеры настройки узла HTTP Request

#### 1. Добавление/Обновление одного секрета

- **Method:** `POST`
- **URL:** `http://vault_n8n/api/v1/secrets/single`
- **Body Content Type:** `JSON`
- **JSON:**
  ```json
  {
    "key": "n8n_secret_key",
    "value": "n8n_secret_value"
  }
  ```
  Вы также можете использовать выражения n8n для динамической подстановки значений:
  ```json
  {
    "key": "={{ $json.some_key }}",
    "value": "={{ $json.some_value }}"
  }
  ```

#### 2. Массовое добавление/обновление секретов

- **Method:** `POST`
- **URL:** `http://vault_n8n/api/v1/secrets/bulk`
- **Body Content Type:** `JSON`
- **JSON:**
  ```json
  [
    { "key": "api_key_prod", "value": "prod_api_token_xyz" },
    { "key": "db_user", "value": "admin_user" }
  ]
  ```

#### 3. Получение секретов

- **Method:** `GET`
- **URL:** `http://vault_n8n/api/v1/secrets`
- **Options -> Query Parameters:**
  - Нажмите `Add Parameter`.
  - **Name:** `keys`
  - **Value:** `n8n_secret_key,api_key_*` (можно указывать несколько ключей и маски).

#### 4. Удаление секретов

- **Method:** `DELETE`
- **URL:** `http://vault_n8n/api/v1/secrets`
- **Options -> Query Parameters:**
  - Нажмите `Add Parameter`.
  - **Name:** `keys`
  - **Value:** `n8n_secret_key`

## Тестирование

Для запуска тестов убедитесь, что вы находитесь в клонированном репозитории и активировали виртуальное окружение.

```bash
# Установите dev-зависимости
pip install -r requirements.txt

# Запустите тесты
PYTHONPATH=$(pwd) pytest
```
Эта команда запускает тесты, корректно обрабатывая импорты модулей приложения.

## Публикация новой версии

Этот проект использует [GitHub Actions](https://github.com/features/actions) для автоматической сборки и публикации Docker-образа в [Docker Hub](https://hub.docker.com/).

Публикация новой версии происходит при создании и отправке в репозиторий нового Git-тега, соответствующего формату `v*.*.*` (например, `v1.0.0`, `v1.2.3`).

**Порядок действий для выпуска новой версии:**

1.  Убедитесь, что все последние изменения находятся в ветке `main`.
2.  Создайте новый тег, следуя принципам [семантического версионирования](https://semver.org/lang/ru/).
    ```bash
    # Пример создания тега для версии 1.0.1
    git tag v1.0.1
    ```
3.  Отправьте тег в удаленный репозиторий.
    ```bash
    git push origin v1.0.1
    ```
4.  После этого GitHub Actions автоматически запустит процесс сборки и публикации.

## Общие технические требования

- **Язык**: Python 3.11
- **Web-фреймворк**: FastAPI
- **База данных**: SQLite
- **Шифрование**: AES-256-GCM
- **Тесты**: `pytest`
- **Контейнеризация**: Docker

## Советы по безопасности и эксплуатации

-   **HTTPS**: Всегда запускайте VaultN8N за обратным прокси (например, Nginx, Traefik), который обеспечивает HTTPS.
-   **Сетевая изоляция**: Ограничьте доступ к API VaultN8N только для доверенных сервисов (например, n8n).
-   **Управление ключами**: `ENCRYPTION_KEY` и `AUTH_TOKEN` в файле `.env` должны быть надежно защищены.
-   **Резервное копирование**: Регулярно создавайте резервные копии файла базы данных (`secrets.db`).
---
